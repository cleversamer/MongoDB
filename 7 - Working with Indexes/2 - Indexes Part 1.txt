MongoDB gives us a nice tool that we can use to analyze how it executed the query, and this tool is a simple method we add to our query.
We can add the explain() method and then chain our normal query, explain works for find, update, delete, and not for insert.
We can pass an argument to explain() method, and that argument is a string where we control the verbosity of this command.
If we pass "executionStats" to explain() method, then we find a detailed output for a query, and how the results were returned.

For example: db.<collection>.explain("executionStats).find(<query>)

* How can we add a single field index?

Let's view the explanation of the operation of finding all people who are older than 60:
mongo
use contactData
db.persons.explain("executionStats").find({"dob.age": {$gt: 60}})

We find some important results in the explanation object in the "executionStats" property:
"nReturned" : 1222,                     => Means number of documents that matched the filter.
"executionTimeMillis" : <some number>,  => Means time took to execute the operation (it differs from computer to another).
"totalKeysExamined" : 0,                => Means number of index keys examined.
"totalDocsExamined" : 5000,             => Means number of documents examined.
"executionStages.stage" : "COLLSCAN"    => Means type of scan/query which is in this case column-scan (scan the entire collection).

As we see, our query scanned the entire collection to give us the result.

Let's add an index to improve our query, and look at the results:
HINT: We can create an index by the following syntax => db.<collection>.createIndex({<field>: <1 | -1>})
HINT: The number we specify when we create an index simply means ascending/descending order (1 for ascending, and -1 for descending).
mongo
use contactData
db.persons.createIndex({"dob.age": 1})
db.persons.explain("executionStats").find({"dob.age": {$gt: 60}})

We find some important results in the explanation object in the "executionStats" property:
"nReturned" : 1222,                            => Means number of documents that matched the filter.
"executionTimeMillis" : <some number>,         => Means time took to execute the operation (it differs from computer to another).
"totalKeysExamined" : 1222,                    => Means number of index keys examined.
"totalDocsExamined" : 1222,                    => Means number of documents examined.
"executionStages.inputStage.stage" : "IXSCAN"  => Means that the query used indexes (IXSCAN => Index scan).

We see that the "executionTimeMillis" is down significantly.
That's the impact of using indexes. It speeds up our queries.

* What does createIndex() do in detail?

Whilst we can't really see the index, we can think of the index as a simple list of values and pointers to the original document.
Something like this (for the "age" field):
(29, "address in memory/ collection a1")
(30, "address in memory/ collection a2")
(33, "address in memory/ collection a3")

The documents in the collection would be at the "addresses" a1, a2 and a3.
The order does not have to match the order in the index.

The important thing is that the index items are ordered (ascending or descending - depending on how we created the index).
createIndex({age: 1}) creates an index with ascending sorting.
createIndex({age: -1}) creates one with descending sorting.

MongoDB is now able to quickly find a fitting document when we filter for its "age" as it has a sorted list.
Sorted lists are way quicker to search, because we can skip entire ranges (and don't have to look at every single document).

* What is Index Restriction?

So we had a look at our first index, and this index actually sped up our query.
It sped up our query for people older than 60.
Now something interesting happens if we do run the same query for people older than 20.
If we do run this query, it's still super fast but what we see is that we essentially seem to have no person in our dataset that is 
younger than 20. We'll have to go through the entire index, and every single element matches our query, and then we fetch documents
for that, and we will see that the execution time for this is higher than it was for people older than 60:

db.persons.explain("executionStats").find({"dob.age": {$gt: 20}})

Now something interesting happens if we get rid of that index:
db.persons.dropIndex({"dob.age": 1})

And now let's run the same query again and explain it:
db.persons.explain("executionStats").find({"dob.age": {$gt: 20}})

Now that we have no index. What we'll see is that this now actually is faster, because we save the step of going for the index.
If we have a query that will return a large portion or the majority of our documents, an index can actually be slower because we 
then just have an extra step to go through our almost entire index list and then we have to go to the collection and get all these 
documents.
So we then just have an extra step because if we do a full collection scan, it can be faster and it certainly is if we return all 
elements but even for the majority it would be faster because with a full collection scan, we already have all the documents in memory
and then an index doesn't offer us any more because that just is an extra step.
So if we have queries that regularly return the majority or all of our documents, an index will not really help us there.

* How can we create Compound Indexes?

Let's say that we want to use index to find all contacts that are both greater than 30 and male. Here we use a Compound Index!
Let's make a new index for both "dob.age" and "gender" with ascending order:
db.persons.createIndex({"dob.age": 1, gender: 1})

Now we have a compound index, we can use it to speed up our queries for both properties (age and gender).
We can also use this index to query documents with only "age" property.

* How can we use indexes for sorting?

It's important to understand that indexes are not just used for finding, but they can also help us with sorting because we have
a sorted list of elements of the index.
MongoDB can utilize that in case we want to sort in the same way that index list is sorted.
Let's find all people with an age of 35 and then sort them by gender in ascending order:
db.persons.explain("executionStats").find({age: 35}).sort({gender: 1})

We see that it did actually use an index scan (IXSCAN) for both gender and age.
Now also important to understand or to know here is that if we are not using indexes and we do a sort on a large amount of documents,
we can actually timeout because MongoDB has a threshold of 32MB in memory for sorting, and if we have no index, MongoDB will essentially
fetch all our documents into memory and do the sort there.
And for large collections and large amounts of fetched documents, this can simply be too much to then sort.
So sometimes, we also need an index not just to speed up the query which always makes sense but also to be able to sort at all.

Something important to keep in mind that when we're sorting documents, and we have a lot of documents at a given query, we might 
need an index to be able to sort them at all, because MongoDB has this threshold of 32MB which it reserves in memory for the fetched
documents and sorting them.